# 索引

## 索引的意义
mysql是基于磁盘进行数据持久化的，而磁盘IO相当耗性能，比内存操作慢几个数量级。所以需要对数据建立索引加快查询效率。

## B+树
用于高效搜索的数据结构有很多，比如树类型中的二叉树。如果树是平衡的，时间复杂度是logn。但是我们知道，mysql的索引结构采用的是B+树。为什么？
回到最开始的问题，mysql最大的性能瓶颈在于磁盘，所以一切都要围绕降低磁盘操作来设计。B+数一种矮宽型的树结构，层数很低，而树的高度和磁盘IO次数相关，这正好满足了mysql的需求。
B+树有几个关键设计：
- 非叶子节点仅存索引，不存实际的数据。这样使得每一个节点可以存放更多的索引，也就可以在一个索引节点索引更多数据，降低了树的高度。
- 叶子节点存实际的数据，并且叶子节点之间是双向链表。这意味着找到第一个满足条件的数据后，不需要再从索引树查找了，可以直接利用叶子结点的指针向后查询。
索引节点能索引的数据量等于磁盘page大小除以索引项大小，索引项大小基本就是指针和索引值。
在索引节点内部使用二分查找定位索引，这个是内存操作，时间消耗基本可以忽略。

## 索引类型
- 聚簇索引，也叫主键索引。每一张表有且仅有一个聚簇索引。聚簇索引指的由主键primary key指定的列构建的索引。如果没有指定，mysql会用全列名自动生成一个主键索引。主键索引的叶子结点是完整的记录行，意味着
  通过聚簇索引就能直接定位一条记录。
- 二级索引，也叫普通索引。指的是除了主键索引之外的索引。其叶子结点存放的是主键索引值，所以通过二级索引查询数据需要回表，先查到主键索引值，再通过主键索引查数据行，这个过程叫做回表。
- 唯一索引，TODO

## 复合索引
指的是一个索引包含了多个列。符合索引不等于多个单列的索引。复合索引遵循最左匹配原则。建立复合索引时应当将等值查询的列放在前面，范围查询的列放在最后。复合索引的列名以及顺序完全取决于业务查询的条件。
举个例子：用户表有一个索引idx(name,age,time)。那么查询条件`name="张三"  and age = 12 and time > "2021-10-11"`就能用上这个索引。相反如果是idx(name,time,age)就不行了。也就是说范围查询之后的条件列不能用索引。
所以符合索引中如果要放时间，而且根据范围查询，时间列应该放在最后。

建立索引(a,b)，可以用于a的查询以及a和b一起的查询。如果还要针对b查询，只能额外再建立b的索引。

对于查询`a=1 and b = 2 and c = 3`，复合索引abc的顺序没有关系。

## 索引覆盖
通过二级索引查询数据需要回表，但是如果需要查询的列已经在索引中了，就不需要回表。可以利用这个特性将需要查询的字段加入到复合索引中。

## 索引下推
对于无法使用索引的查询条件，需要回表数据行后再过滤，索引下推允许在索引行上进行过滤，减少回表数量。比如查询
`name like "%张" and age > 12`对于索引idx(name,age)而言。age虽然无法直接使用复合索引，但是可以再索引树上进行过滤后再回表。

## 唯一索引
唯一索引可以保证唯一性，相比于普通索引，会有些代价。从原则上讲，业务上有唯一性的要求，还是要建立唯一索引。否则就应该建立普通索引。
那么二者的区别在哪里？
在读操作中，基本没有区别。唯一索引无非是找到第一条记录就返回，而普通索引需要继续往下查。
区别在写操作中。

### change buffer
mysql的写操作需要更新redo log和内存buffer。正常来说，如果数据page不在内存buffer中，需要将数据从磁盘读入。但是mysql为了进一步提升性能，使用change buffer
暂存了更新操作，减少了磁盘随机IO，等到需要读取数据时才从磁盘读入并且应用change buffer的改动，这是一种写入优化。但是对于写入后立马就要读的场景，change buffer就没有用了，反而额外维护内存buffer造成了开销。所以change buffer适用于写多读少的场景。
唯一索引需要判断唯一性，如果内存中没有数据，必然需要从磁盘读入才能判断唯一性，因此change buffer不适用于唯一索引。
对于内存中不存在的数据，普通索引由于可以使用change buffer的优化，比唯一索引更加高效。

实践：能用普通索引的尽量用普通索引，更新效率高。

## 字符串索引
像身份证这样的数据列建立的索引会占用较大空间，但是又有查询需求如何能兼顾存储和效率呢？
这里仅仅针对身份证列等值查询的情况，主要考虑到身份证号的后几位是随机的，建立索引的意义更大。
方式一：hash索引，单独加一hash列，存储身份证的hash值，hash值只占用有限个字节。查询的时候用hash值查。
方式二：倒序索引，存身份证号时倒着存，建立索引时仅针对前几位建立。查询的时候也倒着查。
感觉绝大多数情况下应该不用这么优化，看具体场景吧。

## 索引选择
一条查询语句选择什么索引是由优化器来决定的。优化器考虑的因素主要包括：
- 索引的区分度
- 扫描行数
- 是否有排序

### 索引区分度
指的是某一索引列的值的基数。这个值mysql怎么拿到？mysql通过采样分析得到，当更新行数达到某一个阈值，mysql会从某一些数据页上的数据进行采样，得到索引的区分度。可以使用show index from tablexxx命令查看。

### 扫描行数
有时候mysql不会使用索引，是因为它判定使用索引的扫描行数虽然比全表扫描少，但是也很大，使用索引还会涉及回表，所以可能全表扫描更好

### 排序
排序也是mysql选择索引的考虑因素

## force index
总之，优化器的各种评估因素可能与我们想的逻辑有偏差，导致mysql最终没有使用我们建立的索引。
这是可以采用force index语句强制优化器使用我们指定的索引。

## 参考
- [MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)
- [09 | 普通索引和唯一索引，应该怎么选择？](https://time.geekbang.org/column/article/70848)
- [10 | MySQL为什么有时候会选错索引？](https://time.geekbang.org/column/article/71173)