本文没有对DDL进行太细节的分析，这里只是了解下大致思路。
DDL全程Data Definition Language，指的是操作表结构变更的语句即alter语句。
DDL的核心问题是，变更期间是否中断用户的DML语句（update/delete/insert）。如果不中断，我们称之为Online DDL。

# mysql 5.6之前
在mysql早期版本即5.6以前是不支持Online DDL的。其原理大致是新建一张表，执行DDL语句，再把原有数据表的数据导入新表，删除原表，重命名新表。整个过程会锁表，中断客户端DML请求。

# mysql 5.6及之后
绝大部分语句支持了online DDL，其原理大致是扫描原始表生成新结构下的数据文件。在这期间的DML语句记录在rowlog临时文件中，当数据文件生成完毕后，回放rowlog文件。替换原有文件。
核心的点在于缓存了扫表期间的DML操作。当然这个过程在最后替换数据文件时需要加锁，有一小段时间阻塞。
该方案的问题是，扫表期间的DML语句执行存在延迟，因为只是缓存并未生效。

# gh-ost
除了mysql官方提供的解决方案，业界还有第三方解决方案。典型的比如github项目gh-ost。
其原理大致是，新建一张DDL后的新表，有一个扫表任务，将原表的数据插入新表中。同时新表会接原表的binlog事件，将变更在新表上回放。当扫表结束后，用新表代替原表。
可以看到，DDL期间的变更是实时生效的，解决了mysql online DDL方案中使用rowlog缓存导致变更生效延迟的问题。
但这里有一个问题：如果一个变更binlog事件到达了新表，但是该条数据还没有被同步到新表呢？这就会导致一次空变更，致使新表上变更丢失。
其实空变更也没问题。因为老表上变更已经生效了，之后同步到新表时，已经带上了变更。看似有问题，实际没问题。
另外需要注意的是，在DDL期间的读取操作都是基于老表的，因为新表数据不全。

# 参考
- [MySQL Online DDL 探究](https://huangzhw.github.io/2018/09/20/mysql-online-ddl/)
- [MySQL 8.0 Online DDL和pt-osc、gh-ost深度对比分析](https://zhuanlan.zhihu.com/p/115277009)
