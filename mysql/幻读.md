# 关于幻读

## 定义
幻读是指同一个事务内的两次查询，后一次看到了前一次没有的结果。
关于幻读产生的时机：
- 当前读，也就是加锁的select以及update、delete和insert更新语句才会发生。如果是快照读，在RR级别下，由于MVCC的视图控制，是无法读到新插入的行的。
所以在RR级别下，事务A：select，事务B：insert，事务A：select。两次select内容肯定相同，无法复现幻读，这是因为MVCC机制。
结论：**在RR级别下，快照读根本不会有幻读的问题。会出问题的是当前读**。
- 仅仅指新插入的数据。

## 当前读下幻读的问题
结论：为了解决RR级别下当前度的幻读问题，mysql引入了间隙锁。这里为了分析引入间隙锁的必要性或者当前读下幻读问题的影响，先假设没有间隙锁只有行锁的情况。
如果是这样的话，会导致主从数据的不一致。
举个例子：
```sql
CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;
insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);
```
事务A先执行更新:
```sql
begin;
select * from t where d = 5 for update;
update t set d = 100 where d = 5;
```
此时，d=5只有id=5的一条记录，所以可以读到一行。也只有这条记录会被修改，(5,5,5) -> (5,5,100)
事务B执行插入：
```sql
insert into t values(1,1,5);
```
数据库内多了(1,1,5)的记录。
由于事务B只有一条记录，自动commit，从库也会插入(1,1,5)这条记录。
之后事务A执行当前读并commit：
```sql
select * from t where d = 5 for update;
commit;
```
此时会读到两条记录，发生了幻读。这个幻读会导致主从数据不一致。
从库收到`update t set d = 100 where d = 5;`这条语句，执行时，发现共有两条d=5的数据：(5,5,5)和(1,1,5)，最终这两条数据都被update，与主库不一致。
当然这里是statement的binlog格式。

## 间隙锁
之所以会发生上述情况，原因是仅仅对数据行加了锁，无法防止新插入数据。所以mysql引入了间隙锁，不仅仅锁住行，还会锁住行与行之间的间隙。
间隙锁是前开后闭区间。
有了间隙锁，事务A执行完第一阶段，会对全表上锁（全表扫描），这样B执行insert语句时就会被锁住，直到A事务commit。这样就可以避免刚才的数据不一致问题。
tip：全表扫描会导致全表加间隙锁，所以加索引很有必要。因为加锁是针对使用的索引列加的，所以就是对主键索引加；而条件又是在非索引列上限制的，索引主键索引等于用不到，所有行都加锁。
另外需要注意的是，间隙锁仅仅在RR级别下生效，在RC级别想要避免数据不一致问题，需要开启row模式binlog。

## 结论
在RR级别下，MVCC解决了快照读的幻读问题，间隙锁解决了当前读的幻读问题。

## 参考
- [20 | 幻读是什么，幻读有什么问题？](https://time.geekbang.org/column/article/75173)
- [update 没有索引，会锁全表！](https://bbs.huaweicloud.com/blogs/300169)