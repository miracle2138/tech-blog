# 自增主键

## 自增主键优势
- 自增主键的插入都是顺序插入，造成节点分裂的概率较低。
- 插入的是同一块数据页，不会造成数据页的频繁加载。

## 使用场景
什么场景下不能使用？
- 双主架构：可能导致主键冲突，这种情况需要使用全局的id生成器保证双主id不会冲突。
- 确定只需要一种索引，且是唯一索引，可以直接使用该列做自增主键，减少回表，加快查询性能。
其他场景都建议使用自增主键。

## 自增主键怎么存？
mysql5.7及之前的版本，存储在内存中。如果重启，会查询max（id）作为新的自增id值。可能导致自增id被修改。举例：当前自增id=11，删除了id=10的记录，重启，下一个可用的自增id变成了10。
mysql8版本，自增id被持久化到redo log中，不会丢失。

## 自增主键更新时机
如果更新语句没有指定主键id，那么会使用当前记录的最大id值赋值，然后将id自增。之后执行插入语句，如果插入失败，id不会回退。
为什么id不回退？
如果回退，别的事务申请了更大的id = A且执行成功，当前事务由于回退使用了一个更小的id，之后还是会用到A这个id，从而导致主键冲突。

## 自增锁
为了防止多个事务申请到相同的自增id，需要加锁，加锁范围是什么？
一种是申请完后就立刻释放，另一种是语句儿指定完再释放。具体取决于参数 `innodb_autoinc_lock_mode`的值。
- 0: 语句；
- 1: 普通 insert 语句，自增锁在申请之后就马上释放；类似 `insert...select` 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；
- 2: 申请完立刻释放；

为什么会有1的情况？
语句执行完再释放很显然会影响事务执行的并发度。那是不是直接释放更好？直接释放也有问题，比如：
insert...select语句在本事务执行时，如果另一个事务也执行插入，就会导致insert...select的数据的自增id不连续。这样在备库执行时，两个事务是顺序执行的，如果是statement模式，会出现主从数据不一致的情况。
解决这个问题有两种方案：
- 语句儿执行完再释放锁；
- `innodb_autoinc_lock_mode=2`，且binlog格式为row。

## 自增id不连续
从上面的情况看，自增id可能不连续，导致不连续的原因如下：
- 唯一建冲突；
- 事务回滚；
- insert select语句；

## 自增主键id超过最大值
如果已经达到最大值，则自增主键id不会更新，下一次插入会主键冲突。

## 小结
- 明白自增主键的使用场景和优势；
- 自增主键不连续；

## 参考
- [39 | 自增主键为什么不是连续的？](https://time.geekbang.org/column/article/80531)
