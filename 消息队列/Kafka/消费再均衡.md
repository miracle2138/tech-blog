# 消费再均衡

## 什么是消费再均衡
Kafka会让该topic的分区尽可能均衡地被客户端消费。比如topic有3个分区，消费者有2个。
那么一个消费者会消费2个分区，另一个消费1个分区。而不至于出现3个分区全被一个消费者消费的情况。
如果分区数变化或者消费者数变化，可能打破之前的平衡，这时就需要通过再均衡操作恢复平衡。

## 再均衡发生的时机
- topic分区数变化
- 消费者变化，如宕机/新加消费者
- 主题变化，正则表达式？

## 旧版Kafka机制
旧版Kafka再均衡通过zk的watch机制实现，即所有消费者都需要watch集群zk的某一个节点。该节点记录了
集群分区信息以及消费者信息，当分区以及消费者变化时会主动修改zk，这样消费者就可以感知到变化。
这种机制会导致羊群效应。
新版Kafka通过组协调器来实现再均衡。

## 组协调器
组协调器`GroupCoordinator`有两个作用：
- 管理消费者组，实现再均衡
- 处理消费者的位移提交

组协调器就是一个Broker节点。一个消费者组就对应着一个组协调器。
`partition = hash(group_id)/_consumer_offsets topic分区数`，一个消费组的组协调器就是该partition的leader节点。
所以说，组协调器本质上就是__consumer_offsets主题的一个Broker节点。为什么是这个主题？
前面说了组协调器除了管理再均衡，还需要记录位移提交，而__consumer_offsets主题就是记录位移提交的。这样一个节点就可以同时处理这两类事情。

## 消费者协调器
这个叫法感觉挺奇怪，其实就是ConsumerCoordinator，是消费者客户端中与组协调器交互的组件。

## 再均衡过程
由于再均衡过程需要所有消费者交互，那么这个交互就通过组协调器这个代理角色作为中间人完成。
再均衡过程消费者将停止消费。
### 1.寻找组协调器
当新的消费者加入集群，需要通过FIND_COORDINATOR请求发现组协调器。
### 2.加入消费者组
组协调器会通知所有的消费者重新加入消费组，消费者会发送JOIN_GROUP请求。
Broker端收到请求将请求转交给组协调器。组协调器会选举消费者leader，策略是第一个加入消费组的消费者。
之后组协调器给各个消费者回复响应，给leader的响应会额外包括组员信息以及分区方案，由leader进行分区方案的确定。
所以组协调器仅仅是一个"中介"，不负责具体策略的制定。
### 3.同步结果
leader确定了分区方案后，使用SYNC_GROUP请求将方案通过组协调器同步给各个消费者。并且将分区方案记录在_consumer_offsets主题内。
所以该主题记录了两部分信息：位移+分区
### 4.心跳
至此消费者就可以开始工作了，首先会拉取新的位移。之后会通过和组协调器的心跳机制保活。如果超过一定时间没有心跳，
组协调器就会重新发起再均衡。

## 消费者分区策略
分区策略默认有3种，当然业务可以自定义实现。总的来说，不同的分区策略其视角是不同的。
有的策略关注的是集群整体的均衡性，有的真是某一个主题内部或者某一个消费者组的均衡性。
- RangeAssignor：对于每一个消费者组是内均衡的。简单的除模运算。可能导致集群不均衡，比如两个主题t1和t2，都有3个分区（0，1，2）。两个消费者c1和c2军订阅了t1和t2。最终的方案是：
  c1：[t1p0,t1p1,t2p0,t2p1]，c2：[t1p2,t2p2]，整体上c1的负载要大过c2
- RoundRobinAssignor：将主题和分区按照字典序列出来，均匀的分配给每一个消费者。还是上面的例子，排列为：t1p0,t1p1,t1p2,t2p0,t2p1,t2p2，结果为：
  c1：[t1p0,t1p2,t2p1]，c2：[t1p1,t2p0,t2p2]，从集群上也是均衡的

## 参考
[0](https://juejin.cn/book/6844733792683458573/section/6844733793203388430)
[1](https://juejin.cn/post/6876428477445177351)
