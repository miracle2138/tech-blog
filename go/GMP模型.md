# GMP模型

## 简介
Go语言的协程本质上用户态线程，与内核线程是N:M对应关系。
由于1:1以及1:N的线程模型都存在一定的弊端。所以go语言提出了GMP模型来实现M:N模式。

## GMP概念
- G：协程，使用go关键字可以启动一个用户协程。属于用户级线程。
- M：内核级线程。G需要放在M上运行。
- P：一个中间层，拥有G的运行队列，同时绑定若干个M，实现特定的调度策略，让G可以以一定并发度在M上运行。
创建上限由`GOMAXPROCS`指定。虽然一个P可以关联若干个M，但是同一时刻只能有一个M执行。所以并发度实际上是由`GOMAXPROCS`决定的。

## 演进
早期只有GM模型。G由一个全局队列统一管理。M是一个线程池，每一个M都从G队列里取G运行。
这个模型的弊端有：
- G的全局队列会被并发操作，需要加锁
- 局部性较差，M1创建的G执行时，可能分配到M2

## GMP机制
![](https://raw.githubusercontent.com/miracle2138/tech-blog/main/go/file/gmp.png)
(图片引自[https://www.kancloud.cn/aceld/golang/1958305](https://www.kancloud.cn/aceld/golang/1958305))

窃取机制：当一个P无可执行的G时，会尝试从其他P窃取G执行，如果窃取不到，则尝试从全局队列里取
hand-off机制：如果一个P的M陷入阻塞，P会将M和自己接触绑定，申请一个新的M执行其余的G。想想这个怎么实现的？？
抢占：为了防止某一个G占用太多的时间，P的调度是支持时间片的
并行：一个P同时只拥有一个在运行的M，所以整个系统的并发度取决于P的数量
综上，go的调度器在用户态解决了调度的两个问题：**阻塞时调用**以及**分时调度机制**

## 过程
- 通过 go func()来创建一个goroutine
- 有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中
- G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行
- 一个M调度G执行的过程是一个循环机制
- 当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P
- 当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态，加入到空闲线程中，然后这个G会被放入全局队列中
