# 调度器

## 简介
了解了GMP模型以及协程的概念后，我们不禁会问G的调度是如何实现的呢？
我们可以从这两个角度思考下：
- 阻塞式调度是内核层面实现的，在用户态没有控制权，那么调度器是如何在阻塞调用时将M和P解耦从而使得当前的G继续执行呢？
- os的分时调度依赖中断，也是内核层面的机制，调度器是用户态执行的，无法感知中断，那又是如何做到分时呢？

## 演变
- 单线程调度器：单线程的GM模型
- 多线程调度器：多线程的GM模型，锁竞争
- 任务窃取调度器：GMP模型，存在协程饥饿问题
- 抢占式调度器：加入抢占机制

## 关于抢占式调度的实现机制
我们知道任务窃取调度器无法解决协程饥饿的问题。所以引入了抢占式调度模式。分为两种：协作&&信号

### 基于协作的调度
协程的调度代码封装在一个schedule函数中
大致思路是：
- 编译器植入代码一段抢占代码A
- 在G的数据结构里加一个是否可以被强占的标记字段`stackguard0`
- 在GC以及守护线程里加入一段检测逻辑，判断当前G是否执行了足够的时间（10ms），如果是则将其标记字段`stackguard0`置为true
- G的所有函数执行入口时，会触发编译器植入的代码A，代码A会检测`stackguard0`是否为true，如果是，则调用schedule函数触发一次协程调度
基于这种机制实现了时间片调度策略。

### 基于信号的调度
上述调度方式强依赖函数的调用，如果在函数内部执行时间很长，例如for循环，则无能为力。所以后续又出了基于信号的调度策略。
大致思路是：
- 注册信号`SIGURG`的处理函数`runtime.doSigPreempt`
- 在GC的扫描阶段挂起running状态的G，发送信号`SIGURG`
- 操作系统接收到信号，调用`runtime.doSigPreempt`
- `runtime.doSigPreempt`会将G的可被抢占标记置为true，而后调用schedule函数完成调度

可以看到分时的调度是基于上述两种调度机制实现的，本质依赖在用户态植入特定的时机触发schedule函数

### 系统调用
如何做到P执行系统调用时主动让出cpu调度其他G呢？
go的runtime将系统调用进行了封装，在之前和之前分别植入了`entersyscall`以及`exitsyscall`函数。
`entersyscall`函数会将M和P分离，这样P不会因为系统调用而阻塞，P可以选择其他的M或者新建M来运行剩余的G。
当系统调用结束后，会执行`exitsyscall`。`exitsyscall`会帮M找到新的空闲P执行。

这里我们看到，go语言在用户态的调度器上植入了各类黑科技，来达到用户态调度的目的。借助GC、编译、信号等时机完成调度的操作。

## 参考
- [6.5 调度器](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)