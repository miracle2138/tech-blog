## 缓存设计点
缓存这个话题很大，主要指缓存以及db的更新、读取策略。这里介绍cache-aside以及write-back两种。

### cache-aside模式
#### 简介
绝大数企业级应用层使用的模式，该模式涉及两点：
- 缓存加载：如果缓存miss，从db回源，同时回写缓存
- 缓存更新：先更新db，再删除/更新缓存。通常基于binlog方式。

#### 注意点
- 缓存加载时有两个注意点：
  - 空值：如果数据在db里也不存在，会导致缓存穿透，即每一次请求都回源db，解决办法是db不存在就在缓存里写一个empty holder值，代表已经回源过db了，读取时过滤掉
  - 并发控制：缓存过期的一瞬间，会导致大量请求miss穿透到db，需要加锁保护，保证只有第一个请求可以穿透，其余请求hold住。
- 缓存更新时，优先更新db，只有在db中写入成功才算成功。对于缓存更新方式，推荐删除缓存。因为如果是更新缓存，两个并发的更新操作可能导致db-缓存数据不一致。但即使是删除，也会存在
  极端情况下出现不一致情况（读写并发情景）。
- 过期时间，上面说了无论哪种方式，由于对db和缓存的操作不是事务，必然会出现不一致情况，因此给缓存加过期时间很必要，可以保证最终一致性

#### write-back模式
其实读取逻辑都一样，都是"如果缓存miss，从db回源，同时回写缓存"这一套。各个模式的区别主要在于更新。
前面的cache-aside是以db为主，先写db，可靠性优先，可以确保数据不丢失。
这里的write-back模式是缓存优先，先写缓存，然后异步刷回db。这种方式性能好，但是已丢数据，导致数据不一致。
企业级应用通常不会用这种模式。但是在很多底层系统比如mysql、操作系统中，
会大量使用这种模式，因为这些系统往往更注重性能。比如mysql使用的WAL机制，写入操作只写内存buffer，为了防止数据丢失还将变更写入redo log。
操作系统则是在OS级别做了缓冲，后台异步fsync刷新磁盘。

### 参考
- [0](https://juejin.cn/post/6844903604998914055)
- [1](https://blog.csdn.net/u010900754/article/details/92088107)
