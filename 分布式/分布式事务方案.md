## 分布式事务解决方案
单机事务通常是指数据库的ACID特性。但是在分布式或者微服务的场景下，多个操作也需要满足事务的特性，尤其需要保证原子性。这多个操作可能是多个数据库操作或者多个rpc调用。
这样的场景被称为分布式事务。

### 2PC
通常指的是跨实例的数据库事务场景。有两种角色：参与者和协调者。协调者是对外的代理，调用方不必知道分布式事务的执行过程。参与者是数据库实例。
2PC将事务的执行分为了两个阶段：preCommit和doCommit。
preCommit：只执行操作，不提交；协调者先向各个参与者发送preCommit指令，参与者本地执行数据库操作，并将执行结果发回给协调者
doCommit：如果参与者全部返回成功，协调者向各个参与者发送doCommit指令，参与者本地提交事务，否则只要有一个返回失败，就发送abort指令回滚事务。

2PC的问题：
- 单点：协调者单点问题
- 阻塞：如果某一个参与者挂了，整个过程将被阻塞，占用了事务资源
- 数据一致性：在第二阶段，可能部分参与者无法接收到指令，将会导致实例状态不一致

### 3PC
是对2PC的扩展。
- 新增了一个preCommit的阶段，这个阶段什么也不做，协调者只是询问各个参与者是否可以参与事务的执行。如果不行，则终止。加入这个阶段的好处是可以提前检查出异常节点，
  这样就不用占用其他节点的事务资源了
- 参与者也加入超时机制，在doCommit阶段，如果参与者在一段时间内没有收到协调者指令，默认执行commit。

3PC在一定程度上缓解了2PC的问题，但是一致性问题仍然存在

### 本地事务表
本地事务表是一种支持rpc调用的基于重试的最终一致性分布式事务方案。其核心思路是将多个事务操作记录为消息，通过不断重试确保每一个操作最终成功。消息的写入是事务的。
其实现方式有两种：基于数据库；基于事务消息。
假设现在有一个微服务要实现转账和订单两个操作，根据业务本身，需要转账和订单两个数据库。假设订单数据在本微服务下维护，转账需要调用远程rpc，下面介绍下两种方案。
- 不使用事务消息
需要额外一张消息表记录转账操作，确保最终一致性。
创建订单和写入消息表是单机事务操作。
后台轮询服务负责从事务表中取出消息，调用转账服务，并更新消息执行状态。如果失败进行重试。
这里有一些变种，比如轮询服务可以不直接调用下游，而是发送消息，下游consumer消费消息执行转账，并更新消息状态。
由于需要进行重试，这里需要保证下游接口是幂等的。如果下游是幂等的，超时可以当作失败进行重试。

- 使用事务消息（rmq）
转账操作封装成半消息发送。
执行本地订单数据库操作。如果成功，提交半消息，否则回滚半消息。
对半消息的确认可能超时，需要producer提供回查接口，双工通信。所以这里还是需要消息记录表来跟踪每一条消息的执行情况。
下游消费已提交的半消息，执行转账。如果失败消息队列支持重复消费。

- 小结：最终一致性；消息表

### TCC
TCC是一种基于补偿机制的分布式事务解决方案，所谓"补偿"可以理解为"回滚"。与基于重试的最终一致性方案如本地事务表的不同点在于，如果事务某一步执行失败，会对一致性的操作进行回滚。

核心理念：
- 将事务操作划分为三种类型
  - Try：资源预占，是一种中间状态。那扣款举例，账户余额为100，本次事务需要扣款30.常规的业务逻辑是直接对账户进行扣减，如account -= 30。而如果引入了资源预占，30不会直接扣减，而是冻结。那冻结又是什么含义？
    是一种中间状态，可以理解为"这30块正在被扣"，业务上这30是不能为用户所用的，但是仍未被扣掉。其作用就是可以方便回滚。引入"中间状态"可能在扣款的场景下体现的不明显，那如果换成加钱呢？
    例如账户余额为100，本次事务需要转账加钱30.如果直接加，账户余额就是130，那用户就可以直接使用130的余额，如果之后再回滚，可能发现那30已经被花出去了，无法回滚。这就是引入"中间状态"的原因，可以方便实现回滚。
    从业务上来说，不一定所有的业务操作都需要Try阶段，可以为空操作，取决于业务设计。
  - Commit：如果Try都执行成功，会执行Commit。Commit是为了提交之前的资源预占，使之被最终执行。再拿100余额扣减30的例子，Commit就是把冻结的30真正从账户里扣掉。
    Commit操作需要保证幂等性，如果执行失败TCC框架会重试。幂等性很重要。
  - Cancel：如果Try执行失败，会执行Cancel。Cancel是为了回滚之前的资源预占。同样需要保证幂等性，TCC会进行失败重试。
可以看到，TCC对业务模型有一定的侵入性，需要业务逻辑配合TCC的理念进行改造，符合Try——Commit——Cancel的模式，有一定接入成本。

异常问题：
  - 空回滚：由于网络抖动Try操作可能超时，此时会发起Cancel调用。Cancel执行时发现没有Try执行记录，会直接返回，此时就是一个空回滚。也就是Cancel需要判断Try是否执行。
  - 悬挂：如果发生了空回滚，之前延迟的Try请求可能达到了，此时如果依旧执行Try，预占资源后将不会Commit或者Cancel，造成了资源悬挂问题。所以Try执行时，需要判断二阶段是否执行。如果已经执行，比如发生了空回滚，则应该拒绝执行。
  - 有没有空提交？没有，因为如果Try超时了，肯定执行Cancel而不会执行Commit。所以Commit执行时，Try一定执行并且成功。

引用：
  - [0](https://developer.aliyun.com/article/699681)
