## 拜占庭将军问题

### 描述
一堆将军带队进攻，有两种指令：进攻或者撤退。将军之间需要相互通信，协商出一致的作战方案，即要么全部进攻要么全部撤退。否则如果部分进攻部分撤退是无法接受的，进攻一方会有巨大损失。
理想情况，将军都是忠臣，只要将军数是奇数，每个将军对作战计划进行投票，遵循少数服从多数的原则，总能达成一致的作战方案。
实际情况，将军中可能有叛徒，问题会变得复杂起来。所谓叛徒是指，他会给部分人发出进攻部分人发送撤退，导致将军们最终无法按达成一致性作战方案。
比如两忠一叛的场景，两个忠臣A认为该进攻，B认为该撤退，如果剩下一人是忠臣，无论其投进攻还是撤退，总是可以达成一致性方案的，但是如果是叛军，会给A下进攻，给B下撤退的命令。
在A的视角，收到两票进攻，认为该进攻，在B的视角，收到两票撤退，认为该撤退，最终只有A进攻了，寡不敌众。

### 解法
以上便是拜占庭将军问题的通俗理解。关键点在于：达成`一致性`作战方案，而不管这个方案是否正确，哪怕最终的方案与实际情况不符。理解问题本身很重要。
那么如何在有恶意节点的情况下，达成一致呢？

- 口信型方案：假设叛军为n，忠臣需要3*n + 1
  两忠一叛再加一个指挥官，进行两轮投票。
  - 指挥官发起命令
  - 其余将军再协商一轮
  如果指挥官是忠臣，指挥官发给所有人的命令是一致的，那么剩下的两个忠诚将在第二轮达成一致
  如果指挥官是叛将，发给三人的命令不一致，无论是两个进攻还是两个撤退，总能在第二轮协商时达成一致
- 加签方案：假设叛军为n，忠臣需要2*n + 1
  TODO

### 分类
拜占庭将军问题解决的是分布式场景下最复杂的情况即存在恶意节点的系统，解决此类问题的算法叫做拜占庭容错算法（BFT），比在比特币或者金融领域会有应用。
但是通常我们遇到的分布式系统，不会存在恶意节点，解决这类问题的算法叫做故障容错算法（CFT），比如raft、zab等。
