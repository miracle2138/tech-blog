# 线程模型

## 进程以及调度
需要先了解下操作系统关于线程以及调度的知识。
早期的操作系统只支持进程的概念。os层会采用一定的调度策略来满足各个进程的并行执行需求。主要有两个场景需要考虑：
- 系统调用：一个进程执行了系统调用，本身会被阻塞。os需要将其挂起，让出cpu，安排后续的进程来执行。待系统调用结束后，通过中断机制重新进行进程调度，之前挂起的进程便会恢复执行。
- 时间片：为了避免某些执行耗时久的进程长时间占用cpu导致其他进程饥饿，os往往会采用时间片的方式调度进程。依赖os的时钟中断触发调度。
可以看到，os的调度策略由内核实现，在内核态完成，高度依赖中断机制。

## 线程
到目前为止，os调度的基本单位是进程。为了增加程序执行的并发度，提出了线程的概念。一个进程可以分为多个线程，线程与线程之间并发执行。如果一个线程阻塞，还可以调度其他的线程执行，进程不至于被挂起。

## 线程的实现方式
主要有3类： 

#### 内核态线程
内核可以感知到多线程的存在，os调度的基本单位从进程变成了线程。线程的创建、销毁、调度也都是在内核态完成的。
优点：程序的并发度高，由os直接接管调度，用户态程序不用实现线程的机制。
缺点：线程的实现成本较高，涉及内核/用户态的转换。线程占用的空间较大。

#### 用户态线程
线程的概念以及实现是在用户态完成的。内核只能感知到进程，调度的基本单位还是进程。
占用空间以及切换、创建等发生在用户态，成本相对较低。但是如果不在用户态实现完备的调度策略，并发度不高，一个进程同时也只能有一个线程执行（1：N）。遇到系统调用时，也会导致整个进程被挂起。

## 线程模型
现代操作系统都提供了内核级线程的实现，cpu调度的基本单位是线程，也叫轻量级线程（LWP）。同时各类语言也分别提供了各自的用户级线程的实现。
而用户级线程的运行最终需要绑定到一个内核级线程。根据其对应关系可以分为1：1、1：N以及M:N等3种模型。

#### 1：1
一个内核线程对一个用户线程。相当于线程的调度全部交给了内核。并发度高，但是成本也高。
成本体现在两个方面：
- 内存：内核线程消耗在MB级别，而用户线程在KB级别。
- 切换：需要在内核态完成。
所以太多的线程会影响系统性能。Java语言使用的就是这种模型。

#### 1：N
一个内核线程对N个用户线程。线程的调度策略是现在用户态，成本较低。但是由于os无法感知到线程的存在，如果线程有阻塞操作会使得整个进程阻塞，并发度不高。

#### M:N
M个内核线程对N个用户线程。是前两种策略的混合，综合了2者的优势。go语言使用的就是这种模型，只是将用户态的线程描述为了协程。保证了进程执行的并发度，同时也减低了线程维护的成本。

## 参考
- [线程/协程详解](https://learnku.com/articles/41728)
- [用户级线程到底有什么用？](https://www.zhihu.com/question/307787570)